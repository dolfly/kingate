#define CHECK_FIRST
#include "kingate.h"
#ifndef _WIN32
#include <sys/types.h>
#include <unistd.h>
#include <signal.h>
#include <syslog.h>
#endif 
#include <time.h>
#include <assert.h>
#include "KFilter.h"
#include "KUser.h"
#include "allow_connect.h"
#include "KThreadPool.h"
#include "do_config.h"
#include "log.h"
#include "malloc_debug.h"
#ifdef HAVE_SSTREAM
#include <sstream>
#else
#include "mysstream"
#endif
#include<string>
static const int max_sleep_time=300;
static ThreadInfoList FreeThread;
static intmap m_ip;
static KMutex m_ThreadPoolLock;
//QueueInfoMap requestQ;
//int requestQThreadCount=0;
struct connect_per_ip_t
{
	unsigned ip;
	int per_ip;
};
using namespace std;
#ifndef _WIN32
static sigset_t m_blockset;
static sigset_t m_all;
void recv_notice_thread_ignore(int sig)
{
//	printf("recv signal\n");
	klog(ERR_LOG,"error recv a signal %d in pthread_id=%d\n",sig,pthread_self());
	assert(sig==KINGATE_NOTICE_THREAD);
	signal(sig,recv_notice_thread_ignore);	
}
#endif
string get_connect_per_ip()
{
	stringstream s;
	list<connect_per_ip_t> m_per_ip;
	char ip[32];
	list<connect_per_ip_t>::iterator it;
	bool have_insert=false;
	connect_per_ip_t m_tmp;
       	s << "<html><head></head><body>";
	s << "max_per_ip=" << conf.max_per_ip ;
	m_ThreadPoolLock.Lock();
	intmap::iterator it2;
	for(it2=m_ip.begin();it2!=m_ip.end();it2++){
		have_insert=false;
		m_tmp.ip=(*it2).first;
		m_tmp.per_ip=(*it2).second.total_connected;
		for(it=m_per_ip.begin();it!=m_per_ip.end();it++){
			if(m_tmp.per_ip>(*it).per_ip){
				m_per_ip.insert(it,m_tmp);
				have_insert=true;
				break;
			}
		}			
		if(!have_insert){
			m_per_ip.push_back(m_tmp);
		}
    }
	m_ThreadPoolLock.Unlock();
	s << "<table><tr><td>ip</td><td>connect</td></tr>";
	for(it=m_per_ip.begin();it!=m_per_ip.end();it++){
		make_ip((*it).ip,ip);
		s << "<tr";
		if((*it).per_ip>conf.max_per_ip){
			s << " bgcolor=#CCFF99";
		}
		s << "><td>" << ip << "</td><td>" << (*it).per_ip << "</td>";
		s << "</tr>";
	}
	s << "</table><hr><center>Generated by kingate(" << VER_ID << ")</center></body></html>";
	return s.str();
	
}
inline void cleanRequestQueue(intmap::iterator &it2)
{
        SERVER *tmp;
		list<void *>::iterator it;
        for(it=(*it2).second.q.begin();it!=(*it2).second.q.end();it++){
			tmp=(SERVER *)(*it);
			close(tmp->accept_fd);
			delete tmp;
		//	it=requestQ.erase(it);      
        }
}
int set_max_per_ip(int value)
{
	int old_value=conf.max_per_ip;
	conf.max_per_ip=value;
	if(value>0){
		return old_value;
	}
	intmap::iterator it2;
	m_ThreadPoolLock.Lock();
	for(it2=m_ip.begin();it2!=m_ip.end();){
			cleanRequestQueue(it2);
#ifndef _WIN32
			m_ip.erase(it2);
			it2++;
#else
	        it2=m_ip.erase(it2);
#endif
	}
	m_ThreadPoolLock.Unlock();
	return old_value;
}
inline void * dec_per_ip(unsigned long ip)
{
		intmap::iterator it2;
		void *param;
		if(conf.max_per_ip>0){
			it2=m_ip.find(ip);
			if(it2!=m_ip.end()){//it is a bug
				if((*it2).second.total_connected<2){
			//		cleanRequest
					m_ip.erase(it2);
		//			printf("erase it now\n");
				}else{
					(*it2).second.total_connected--;	
					list<void *>::iterator it=(*it2).second.q.begin();
					if(it!=(*it2).second.q.end()){		
						param=(*it);
						(*it2).second.q.pop_front();
						return param;
					}
				}
			}
		}
		return NULL;
	//	printf("ip=%d,ip=%d\n",(*it2).second,ip);
}

FUNC_TYPE FUNC_CALL run_thread(void *param)
{
	ThreadInfo *m_thread=(ThreadInfo *)param;
	//unsigned long ip;
	bool waited=true;
	//QueueInfoMap::iterator it;
	if(m_thread==NULL){
				return

#ifndef _WIN32

			NULL

#endif

			;	}
	m_thread->pid=pthread_self();
#ifdef _WIN32
	m_thread->hThreadNotice=CreateEvent(NULL,FALSE,FALSE,NULL);
#endif
	server_thread(m_thread->param);	
	for(;;){
		waited=true;
		m_thread->end_time=time(NULL);
#ifndef _WIN32
		pthread_sigmask(SIG_BLOCK,&m_blockset,NULL);//阻塞信号
#endif
		m_ThreadPoolLock.Lock();
		m_thread->param=dec_per_ip(m_thread->ip);
		if(m_thread->param!=NULL){
			waited=false;				
			m_thread->cmd=KINGATE_THREAD_START;
			goto thread_unlock;
		}
		m_thread->cmd=KINGATE_THREAD_NULL;
		total_thread--;
		FreeThread.push_front(m_thread);
	thread_unlock:
		m_ThreadPoolLock.Unlock();
		if(waited){
	#ifdef _WIN32
			WaitForSingleObject(m_thread->hThreadNotice,-1);
		}
	#else
			int recv_sig=0;
			sigwait(&m_blockset,&recv_sig);
		}
		pthread_sigmask(SIG_UNBLOCK,&m_blockset,NULL);
	#endif
		if(m_thread->cmd==KINGATE_THREAD_START){
			server_thread(m_thread->param);
		}else if(m_thread->cmd==KINGATE_THREAD_END){
#ifdef _WIN32
			CloseHandle(m_thread->hThreadNotice);
#endif
			delete m_thread;
				return

#ifndef _WIN32

			NULL

#endif

			;		}else{			
			klog(ERR_LOG,"kingate closed or bug!!in %s:%d(recv awake signal),my pthread id=%d\n",__FILE__,__LINE__,pthread_self());
			delete m_thread;
				return

#ifndef _WIN32

			NULL

#endif

			;		}
	}
	
}
KThreadPool::KThreadPool()
{
#ifndef _WIN32
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_DETACHED);//设置线程为分离
	pthread_attr_setstacksize(&attr,204800);
	signal(KINGATE_NOTICE_THREAD,recv_notice_thread_ignore);
	sigemptyset(&m_blockset);
	sigaddset(&m_blockset,KINGATE_NOTICE_THREAD);
	sigemptyset(&m_all);
#endif
}
KThreadPool::~KThreadPool()
{
}
void KThreadPool::closeAllFreeThread()
{
	ThreadInfoList::iterator it;
	pthread_t pid;//
	m_ThreadPoolLock.Lock();
	for(it=FreeThread.end();it!=FreeThread.begin();){
		it--;
		pid=(*it)->pid;
		(*it)->cmd=KINGATE_THREAD_END;			
#ifndef _WIN32
		if(pthread_kill(pid,KINGATE_NOTICE_THREAD)!=0){
			klog(ERR_LOG,"cann't send signal to thread(command:close,id=%d)\n",pid);
		}
#else
		SetEvent((*it)->hThreadNotice);
#endif
		it=FreeThread.erase(it);
	}
	m_ThreadPoolLock.Unlock();
}
void KThreadPool::Flush()
{
	ThreadInfoList::iterator it;
	int now_time=time(NULL);
	pthread_t pid;//
	m_ThreadPoolLock.Lock();
	for(it=FreeThread.end();it!=FreeThread.begin();){
		if(FreeThread.size()<=conf.min_free_thread)
			break;
		it--;
		if(now_time-(*it)->end_time>max_sleep_time){
			pid=(*it)->pid;
			(*it)->cmd=KINGATE_THREAD_END;			
#ifndef _WIN32
			if(pthread_kill(pid,KINGATE_NOTICE_THREAD)!=0){
				klog(ERR_LOG,"cann't send signal to thread(command:close,id=%d)\n",pid);
			}
#else
			SetEvent((*it)->hThreadNotice);
#endif
			it=FreeThread.erase(it);
		}else{
			break;
		}
	}
	m_ThreadPoolLock.Unlock();
	
}
int KThreadPool::getFreeThread()
{
	int FreeThreadCount=0;
	m_ThreadPoolLock.Lock();
	FreeThreadCount=FreeThread.size();
	m_ThreadPoolLock.Unlock();
	return FreeThreadCount;
}
int KThreadPool::Start(SERVER *param)
{
	ThreadInfoList::iterator it;
	unsigned long ip=param->server->get_remote_addr();
	intmap::iterator it2;
	int ret=0;
	ThreadInfo *m_thread=NULL;
//	QueueInfo m_queue;
//	int total_connected=0;
	stringstream base_rule;
	#ifdef CHECK_FIRST
	unsigned long dst_ip=0;
	unsigned uid=0;
	if(param->model==SOCKS){
		uid=DELAYUSER;
	}
	if(allow_connect(param->model,param->server,NULL,0,dst_ip,false,uid)==DENY){
		close(param->accept_fd);
		delete param;
		return 3;
	}
	#endif
	m_ThreadPoolLock.Lock();
	if(conf.max_per_ip>0){
		it2=m_ip.find(ip);
		if(it2==m_ip.end()){
			QueueInfo m_qinfo;
			m_qinfo.total_connected=1;
			m_ip.insert(make_pair<unsigned long,QueueInfo>(ip,m_qinfo));
	//		printf("now add ip=%d\n",ip);
		}else{	
			(*it2).second.total_connected++;
		//	total_connected=(*it2).second.total_connected;
			if((*it2).second.total_connected>conf.max_per_ip){
				klog(ERR_LOG,"error,refuse %s(%d) try to connect %d ,max_per_ip=%d limit.\n",param->server->get_remote_name(),(*it2).second.total_connected,param->model,conf.max_per_ip);
				param->client=(mysocket *)1;
				(*it2).second.q.push_back(param);
				goto max_per_ip;
			}
		}
	}
	if(total_thread>=conf.max){
			klog(ERR_LOG,"too many user,connect refuse,total_thread=%d\n",total_thread);
			goto err;
	}
	it=FreeThread.begin();
	if(it==FreeThread.end()){//It is no free Thread now	
		m_thread=new ThreadInfo;
		if(m_thread==NULL){
			klog(ERR_LOG,"no mem to alloc\n");
			goto err;
		}
		m_thread->param=param;
		m_thread->ip=ip;
		ret=pthread_create(&id,&attr,run_thread,(void *)m_thread);//
#ifndef _WIN32
		if(ret!=0){
			klog(ERR_LOG,"create thread error.result=%d\n",ret);
			goto err;
		}
#endif
	}else{
		(*it)->cmd=KINGATE_THREAD_START;
		(*it)->param=(void *)param;
		(*it)->ip=ip;
#ifndef _WIN32
		if(pthread_kill((*it)->pid,KINGATE_NOTICE_THREAD)!=0){
			klog(ERR_LOG,"cann't send signal to thread(command:start,id=%d)\n",(*it)->pid);
		}
#else
		SetEvent((*it)->hThreadNotice);
#endif
		FreeThread.erase(it);
	}
	total_thread++;
	m_ThreadPoolLock.Unlock();
	return 1;
max_per_ip:
	if(conf.max_deny_per_ip>0 && (*it2).second.total_connected>conf.max_deny_per_ip){
		klog(ERR_LOG,"kingate add client %s to deny chain,conf.max_deny_per_ip=%d\n",param->server->get_remote_name(),conf.max_deny_per_ip);
        base_rule << "* ";
	    #ifndef DISABLE_USER
		base_rule << "* ";
		#endif
		base_rule << param->server->get_remote_name() << " *"  ;
	   	conf.m_kfilter.MakeChain(base_rule.str().c_str(),NULL,DENY,time(NULL)+3600);
		cleanRequestQueue(it2);
		m_ip.erase(it2);			
	}
	m_ThreadPoolLock.Unlock();	
	return 3;
err:
	m_ThreadPoolLock.Unlock();
	close(param->accept_fd);
	delete param;
	return 3;
}
